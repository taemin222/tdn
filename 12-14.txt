- main 메소드
	-> 해당 java 파일(class)이 실행될 때 제일 먼저 호출하는 (무조건 호출하는) 메소드
	
- main 메소드의 "String[] args" 파라미터
	-> main 메소드는 프로그램 실행 시 처음으로 수행되는 함수이기 때문에, 외부로부터 값을 입력받을 수 있어야 한다.
	-> 값을 args라는 이름의 문자열 배열 형태로 받겠다는 의미.
	
- public static void
	- public
		-> 직역 : 공공의
		-> 접근 제한자
			=> 다른곳(클래스) 에서 사용할 수 있냐 없냐 판단.
		-> 어디서든지(외부 클래스) 찾아 사용할수 있도록 만들겠다. (메소드지향 언어의 장점)
		-> 해당부분을 public이 아닌 protected, private, default 등으로 변경한다면 
			=> protected : "같은 패키지" 또는 "자식 클래스"에서 사용할 수 있다.
			=> private : 단어 뜻 그대로 "개인적인" 것이라 "외부에서 사용될 수 없다".
			=> default : "같은 패키지"에 소속된 클래스에서만 사용할 수 있도록 한다.
			
	- static
		-> 요놈이 인스턴스(ASD a = new ASD()) 생성 없이 클래스명.어쩌구 로 사용 할 수 있는놈이네.
		-> 인스턴스 생성 하지 말라고 한다. 그래서 이전에 노란색 줄 생긴것.
		-> static 사용 안하면 인스턴스 생성 해줘야한다. 일단 여기까지만 알자 (메모리 어쩌구 일단 스킴) 
	
	- void 
		-> 직역 : 무효의
		-> retrun의 유무 판단
		-> return 값을 받지 안겠다. 
		-> 해당부분을 void가 아닌 int, String... 등으로 변경한다면 return 값을 해당 형태로 받겠다는 의미로 변환
			=> 바꾼다면 해당 메소드에 return값을 설정 해줘야 한다.
			=> return값이 없다면 에러
			
- new 연산자
	-> 객체 형태로 변수에 저장.
	-> String a = "a"; => 리터널 방식
	-> String a = new String("a"); => new 연산자 방식
	-> 두 방식의 차이점
		=> 리터널 방식은 다른 변수에 동일한 문자를 저장하면 메모리 주소가 같다. (두 변수 모두 같은곳에 저장)
		=> new 연산자는 객체 형태로 저장하기 때문에 다른 메모리 주소에 저장한다. (두 변소 모두 다른곳에 저장)
	-> 같은 메모리 주소에 저장하는 리터널 방식이 더 이득인거 아냐?
		=> 추후에 함수같은 객체 만들때 재사용면에서 이점이 있음.
		=> 리터널 방식으로 동일한 함수 계속 선언해주는거보다, new 연산자로 쓰는게 맞다. 그냥 이게맞다
		
- Wrapper 클래스
	-> 멀티 쓰레드 환경에서 사용
	-> 인스턴스 생성할 떄 사용하네. 나중에 쓸떄 봐야할듯
	-> Integer num = new Integer(10);		//박싱
		int n = num.intValue();  			//언박싱
		
- package01 ~ package03 작업